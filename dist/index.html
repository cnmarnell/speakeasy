<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>speakeasy</title>
    <script type="module" crossorigin src="/assets/index-xzlg4uV7.js"></script>
    <link rel="stylesheet" crossorigin href="/assets/index-CN1V5Eug.css">
  </head>
  <body>
    <div id="root"></div>

    <!-- Timeout Test Functions (Dev Only) -->
    <script>
      if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        console.log('üß™ Timeout test functions loaded.');
        console.log('Available tests: testDiagnostics(), testTimeout(), runAllTimeoutTests()');

        // DIAGNOSTIC TEST 1: Verify AbortController works at all
        window.testAbortControllerBasic = async function() {
          console.log('\nüî¨ DIAGNOSTIC 1: Testing if AbortController works at all...');

          const controller = new AbortController();
          setTimeout(() => {
            console.log('‚è∞ Aborting after 1 second...');
            controller.abort();
          }, 1000);

          const start = Date.now();

          try {
            await fetch('https://httpbin.org/delay/10', { signal: controller.signal });
            const duration = Date.now() - start;
            console.log(`‚ùå DIAGNOSTIC FAILED: Request completed in ${duration}ms (should have aborted at ~1000ms)`);
            return { success: false, message: 'AbortController not working', duration };
          } catch (err) {
            const duration = Date.now() - start;
            if (err.name === 'AbortError') {
              console.log(`‚úÖ DIAGNOSTIC PASSED: AbortController works! Aborted at ${duration}ms`);
              return { success: true, message: 'AbortController functional', duration };
            } else {
              console.log(`‚ö†Ô∏è  DIAGNOSTIC UNCLEAR: Got error "${err.name}" after ${duration}ms`);
              return { success: false, message: `Wrong error: ${err.name}`, duration };
            }
          }
        };

        // DIAGNOSTIC TEST 2: Check how long httpbin.org/delay/60 actually takes
        window.testHttpbinDelay = async function() {
          console.log('\nüî¨ DIAGNOSTIC 2: Testing httpbin.org/delay/60 actual duration...');
          console.log('‚è≥ This will take up to 60 seconds...');

          const start = Date.now();

          try {
            await fetch('https://httpbin.org/delay/60');
            const duration = Date.now() - start;
            console.log(`üìä httpbin.org/delay/60 completed in ${duration}ms (${(duration/1000).toFixed(1)}s)`);

            if (duration < 55000) {
              console.log(`‚ö†Ô∏è  WARNING: Completed faster than expected (< 55s)`);
            }

            return { success: true, duration, message: `Completed in ${(duration/1000).toFixed(1)}s` };
          } catch (err) {
            const duration = Date.now() - start;
            console.log(`‚ùå httpbin.org/delay/60 failed after ${duration}ms: ${err.message}`);
            return { success: false, duration, error: err.message };
          }
        };

        // Run both diagnostics
        window.testDiagnostics = async function() {
          console.log('\nüöÄ Running diagnostics to identify timeout issue...\n');

          const diag1 = await window.testAbortControllerBasic();
          const diag2 = await window.testHttpbinDelay();

          console.log('\nüìä DIAGNOSTIC SUMMARY:');
          console.log(`1. AbortController: ${diag1.success ? '‚úÖ Working' : '‚ùå Not working'}`);
          console.log(`2. httpbin.org/delay: ${diag2.success ? `‚úÖ Takes ${(diag2.duration/1000).toFixed(1)}s` : '‚ùå Failed'}`);

          if (!diag1.success) {
            console.log('\n‚ö†Ô∏è  ISSUE IDENTIFIED: AbortController is not working in your browser!');
            console.log('This means timeouts will NOT work. You may need to:');
            console.log('  - Update your browser');
            console.log('  - Use a different browser (Chrome/Firefox/Edge)');
            console.log('  - Use Promise.race as a fallback');
          } else if (diag2.duration < 55000) {
            console.log('\n‚ö†Ô∏è  ISSUE IDENTIFIED: httpbin.org is unreliable!');
            console.log(`Expected 60 seconds, got ${(diag2.duration/1000).toFixed(1)} seconds`);
            console.log('This makes httpbin unsuitable for timeout testing.');
            console.log('\nüí° SOLUTION APPLIED: Timeout test now uses Promise.race method');
            console.log('This creates a promise that NEVER resolves, guaranteeing');
            console.log('it will hang until the timeout triggers - 100% reliable!');
            console.log('\nRun testTimeout() to verify timeouts work correctly.');
          } else {
            console.log('\n‚úÖ Both diagnostics passed - timeout should work!');
            console.log('Note: Timeout test now uses reliable Promise.race method');
            console.log('instead of httpbin.org for consistent results.');
          }

          return { diag1, diag2 };
        };

        // Quick timeout test (~30 seconds) with reliable Promise.race method
        window.testTimeoutQuick = async function() {
          console.log('\nüß™ Timeout test starting...');
          console.log('Using Promise.race with never-resolving promise (100% reliable)');

          const controller = new AbortController();
          const start = Date.now();

          const timeout = setTimeout(() => {
            const elapsed = Date.now() - start;
            console.log(`‚è∞ TIMEOUT FIRED at ${elapsed}ms - Calling controller.abort()...`);
            controller.abort();
          }, 30000);

          try {
            console.log('üåê Creating promise that will hang until timeout...');

            // Create a promise that NEVER resolves (guaranteed to hang)
            const hangingPromise = new Promise(() => {});

            // Race between hanging promise and a fetch with abort signal
            // The abort signal allows us to cancel the entire race
            await Promise.race([
              hangingPromise,
              fetch('data:text/plain,test', { signal: controller.signal })
            ]).finally(() => {
              const elapsed = Date.now() - start;
              console.log(`üßπ Finally block executed at ${elapsed}ms`);
              clearTimeout(timeout);
            });

            const duration = Date.now() - start;
            console.log(`‚ùå TEST FAILED: Request completed after ${duration}ms (should have aborted at ~30000ms)`);
            return { success: false, message: 'Did not timeout', duration };
          } catch (err) {
            const duration = Date.now() - start;
            console.log(`‚ö†Ô∏è  Caught error: "${err.name}" after ${duration}ms`);

            if (err.name === 'AbortError') {
              const variance = Math.abs(duration - 30000);
              console.log(`‚úÖ TEST PASSED: Timeout worked! ${duration}ms (expected ~30000ms, variance: ${variance}ms)`);
              return { success: true, duration, message: 'Timeout working correctly' };
            } else {
              console.log(`‚ùå TEST FAILED: Wrong error type: ${err.message}`);
              return { success: false, error: err.message, duration };
            }
          }
        };

        // Full timeout test - alias for consistency
        window.testTimeout = window.testTimeoutQuick;

        // Test fast API call (should succeed)
        window.testTimeoutSuccess = async function() {
          console.log('üß™ Testing fast API call (should succeed)...');

          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 30000);
          const start = Date.now();

          try {
            await fetch('https://httpbin.org/delay/2', {
              signal: controller.signal
            }).finally(() => clearTimeout(timeout));

            const duration = Date.now() - start;
            console.log(`‚úÖ TEST PASSED: Fast request completed in ${duration}ms`);
            return { success: true, duration, message: 'Fast request succeeded' };
          } catch (err) {
            const duration = Date.now() - start;
            console.log(`‚ùå TEST FAILED: Fast request should not timeout: ${err.message}`);
            return { success: false, error: err.message, duration };
          }
        };

        // Run all tests
        window.runAllTimeoutTests = async function() {
          console.log('\nüöÄ Running all timeout tests...\n');

          console.log('=== TEST 1: Fast API Call ===');
          const test1 = await window.testTimeoutSuccess();

          console.log('\n=== TEST 2: Timeout After 30 Seconds ===');
          console.log('‚è≥ This will take about 30 seconds...');
          const test2 = await window.testTimeoutQuick();

          console.log('\n=== RESULTS ===');
          console.log(`Test 1 (Fast API): ${test1.success ? '‚úÖ PASS' : '‚ùå FAIL'} - ${test1.message}`);
          console.log(`Test 2 (Timeout): ${test2.success ? '‚úÖ PASS' : '‚ùå FAIL'} - ${test2.message}`);

          const allPassed = test1.success && test2.success;
          console.log('\n' + (allPassed ? 'üéâ ALL TESTS PASSED!' : '‚ö†Ô∏è  SOME TESTS FAILED'));

          return { allPassed, results: { test1, test2 } };
        };
      }
    </script>
  </body>
</html>
